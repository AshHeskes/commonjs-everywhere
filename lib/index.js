// Generated by CoffeeScript 2.0.0-beta3
void function () {
  var CoffeeScript, esprima, estraverse, EXTENSIONS, fs, path, PRELUDE, relativeResolve, resolve, wrap;
  path = require('path');
  fs = require('fs');
  resolve = require('resolve');
  esprima = require('esprima');
  estraverse = require('estraverse');
  CoffeeScript = require('coffee-script-redux');
  EXTENSIONS = [
    '.js',
    '.coffee',
    '.json'
  ];
  PRELUDE = "function require(file){\n  if({}.hasOwnProperty.call(require.cache, file))\n    return require.cache[file];\n\n  var resolved = require.resolve(file);\n  if(!resolved)\n    throw new Error('Failed to resolve module ' + file);\n\n  var dirname = file.slice(0, file.lastIndexOf('/') + 1);\n  var process = {\n    title: 'browser',\n    browser: true,\n    env: {},\n    argv: [],\n    nextTick: function(fn){ setTimeout(fn, 0); },\n    cwd: function(){ return dirname; }\n  };\n  var module$ = {\n    id: file,\n    require: require,\n    filename: file,\n    exports: {},\n    loaded: false,\n    parent: null,\n    children: []\n  };\n  resolved.call(module$.exports, module$, module$.exports, dirname, file, process);\n  module$.loaded = true;\n  return require.cache[file] = module$.exports;\n}\n\nrequire.modules = {};\nrequire.cache = {};\n\nrequire.resolve = function(file){\n  return {}.hasOwnProperty.call(require.modules, file) ? require.modules[file] : void 0;\n};\nrequire.define = function(file, fn){ require.modules[file] = fn; };";
  wrap = function (file, statements) {
    return {
      type: 'ExpressionStatement',
      expression: {
        type: 'CallExpression',
        callee: {
          type: 'MemberExpression',
          computed: false,
          object: {
            type: 'Identifier',
            name: 'require'
          },
          property: {
            type: 'Identifier',
            name: 'define'
          }
        },
        'arguments': [
          {
            type: 'Literal',
            value: file
          },
          {
            type: 'FunctionExpression',
            id: null,
            params: [
              {
                type: 'Identifier',
                name: 'module'
              },
              {
                type: 'Identifier',
                name: 'exports'
              },
              {
                type: 'Identifier',
                name: '__dirname'
              },
              {
                type: 'Identifier',
                name: '__filename'
              },
              {
                type: 'Identifier',
                name: 'process'
              }
            ],
            defaults: [],
            body: {
              type: 'BlockStatement',
              body: statements
            }
          }
        ]
      }
    };
  };
  exports.relativeResolve = relativeResolve = function (root, givenPath, cwd) {
    var resolvedPath;
    resolvedPath = function () {
      var e;
      try {
        return resolve.sync(givenPath, {
          basedir: cwd || root,
          extensions: EXTENSIONS
        });
      } catch (e$) {
        e = e$;
        return resolve.sync(path.join(root, givenPath), { extensions: EXTENSIONS });
      }
    }.call(this);
    if (fs.existsSync(resolvedPath)) {
      return '/' + path.relative(root, resolvedPath);
    } else {
      return resolvedPath;
    }
  };
  exports.build = function (entryPoint, exposeAs, projectRoot) {
    var aliases, ast, built, canonicalName, fileContents, filename, outputProgram, worklist;
    if (null != projectRoot)
      projectRoot;
    else
      projectRoot = path.dirname(path.resolve(entryPoint));
    worklist = [path.resolve(entryPoint)];
    built = {};
    aliases = { '/lib/make-request.js': '/lib/make-request-browser.js' };
    while (worklist.length) {
      filename = worklist.pop();
      canonicalName = relativeResolve(projectRoot, filename);
      if ({}.hasOwnProperty.call(built, canonicalName))
        continue;
      if ({}.hasOwnProperty.call(aliases, canonicalName))
        filename = resolve.sync(path.join(projectRoot, aliases[canonicalName]), { extensions: EXTENSIONS });
      if (resolve.isCore(filename)) {
        filename = path.resolve(path.join(__dirname, '..', 'core', filename));
        if (!fs.existsSync(filename))
          filename = path.resolve(path.join(__dirname, '..', 'core', 'undefined'));
      }
      fileContents = fs.readFileSync(filename);
      if ('.coffee' === path.extname(filename))
        fileContents = CoffeeScript.cs2js(fileContents);
      if ('.json' === path.extname(filename))
        fileContents = 'module.exports = ' + fileContents;
      ast = esprima.parse(fileContents);
      built[canonicalName] = ast;
      estraverse.replace(ast, {
        enter: function (node, parents) {
          if (!(node.type === 'CallExpression' && node.callee.type === 'Identifier' && node.callee.name === 'require'))
            return;
          if (!(node['arguments'].length === 1))
            badRequireError(filename, node, '`require` must be given exactly one argument');
          if (!(node['arguments'][0].type === 'Literal' && typeof node['arguments'][0].value === 'string'))
            badRequireError(filename, node, 'argument of `require` must be a constant string');
          worklist.push(resolve.sync(node['arguments'][0].value, {
            basedir: path.dirname(filename),
            extensions: EXTENSIONS
          }));
          return {
            type: 'CallExpression',
            callee: node.callee,
            'arguments': [{
                type: 'Literal',
                value: relativeResolve(projectRoot, node['arguments'][0].value, path.dirname(filename))
              }]
          };
        }
      });
    }
    outputProgram = esprima.parse(PRELUDE);
    for (canonicalName in built) {
      if (!isOwn$(built, canonicalName))
        continue;
      ast = built[canonicalName];
      outputProgram.body.push(wrap(canonicalName, ast.body));
    }
    if (null != exposeAs)
      outputProgram.body.push({
        type: 'ExpressionStatement',
        expression: {
          type: 'AssignmentExpression',
          operator: '=',
          left: {
            type: 'MemberExpression',
            computed: true,
            object: {
              type: 'Identifier',
              name: 'global'
            },
            property: {
              type: 'Literal',
              value: exposeAs
            }
          },
          right: {
            type: 'CallExpression',
            callee: {
              type: 'Identifier',
              name: 'require'
            },
            'arguments': [{
                type: 'Literal',
                value: relativeResolve(projectRoot, entryPoint)
              }]
          }
        }
      });
    outputProgram.body = [{
        type: 'ExpressionStatement',
        expression: {
          type: 'CallExpression',
          callee: {
            type: 'FunctionExpression',
            params: [{
                type: 'Identifier',
                name: 'global'
              }],
            body: {
              type: 'BlockStatement',
              body: outputProgram.body
            }
          },
          'arguments': [{ type: 'ThisExpression' }]
        }
      }];
    return outputProgram;
  };
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
}.call(this);
