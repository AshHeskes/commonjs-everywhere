// Generated by CoffeeScript 2.0.0-beta4
void function () {
  var $0, build, cache$, CJSEverywhere, deps, escodegen, escodegenCompactFormat, escodegenDefaultFormat, fs, Jedediah, optionParser, options, originalEntryPoint, path, positionalArgs, root, startBuild, stdinput;
  fs = require('fs');
  path = require('path');
  escodegen = require('escodegen');
  Jedediah = require('jedediah');
  CJSEverywhere = require('./module');
  escodegenDefaultFormat = {
    indent: {
      style: '  ',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    parentheses: false
  };
  escodegenCompactFormat = {
    indent: {
      style: '',
      base: 0
    },
    renumber: true,
    hexadecimal: true,
    quotes: 'auto',
    escapeless: true,
    compact: true,
    parentheses: false,
    semicolons: false
  };
  optionParser = new Jedediah;
  optionParser.addOption('help', false, 'display this help message and exit');
  optionParser.addOption('version', false, 'display the version number and exit');
  optionParser.addOption('deps', false, 'do not bundle; just list the files that would be bundled');
  optionParser.addOption('node', true, 'include process object; emulate node environment (default: on)');
  optionParser.addOption('minify', 'm', false, 'minify output');
  optionParser.addOption('ignore-missing', false, 'continue without error when dependency resolution fails');
  optionParser.addOption('watch', 'w', false, 'watch input files/dependencies for changes and rebuild bundle');
  optionParser.addOption('verbose', 'v', false, 'verbose output sent to stderr');
  optionParser.addParameter('export', 'x', 'NAME', 'export the given entry module as NAME');
  optionParser.addParameter('output', 'o', 'FILE', 'output to FILE instead of stdout');
  optionParser.addParameter('root', 'r', 'DIR', 'unqualified requires are relative to DIR (default: cwd)');
  optionParser.addParameter('source-map', 's', 'FILE', 'output a source map to FILE');
  cache$ = optionParser.parse(process.argv);
  options = cache$[0];
  positionalArgs = cache$[1];
  options.ignoreMissing = options['ignore-missing'];
  options.sourceMap = options['source-map'];
  if (options.help) {
    $0 = process.argv[0] === 'node' ? process.argv[1] : process.argv[0];
    $0 = path.basename($0);
    console.log('\n  Usage: ' + $0 + ' OPT* path/to/entry-file.ext OPT*\n\n' + optionParser.help() + '\n');
    process.exit(0);
  }
  if (options.version) {
    console.log(require('../package.json').version);
    process.exit(0);
  }
  if (!(positionalArgs.length === 1))
    throw new Error('wrong number of entry points given; expected 1');
  root = options.root ? path.resolve(options.root) : process.cwd();
  originalEntryPoint = positionalArgs[0];
  if (options.deps) {
    deps = CJSEverywhere.traverseDependencies(originalEntryPoint, root, options);
    console.log(Object.keys(deps).sort().map(function (f) {
      return path.relative(root, f);
    }).join('\n'));
    process.exit(0);
  }
  if (options.watch && !options.output) {
    console.error('--watch requires --ouput');
    process.exit(1);
  }
  build = function (entryPoint, processed) {
    var bundled, cache$2, code, e, esmangle, file, map, newDeps, sourceMappingUrl;
    if (null == processed)
      processed = {};
    try {
      newDeps = CJSEverywhere.traverseDependencies(entryPoint, root, options);
      if (options.watch)
        for (var cache$1 = Object.keys(newDeps), i$ = 0, length$ = cache$1.length; i$ < length$; ++i$) {
          file = cache$1[i$];
          console.error('built ' + file + ' (' + options.cache[file] + ')');
        }
      for (file in newDeps) {
        if (!isOwn$(newDeps, file))
          continue;
        processed[file] = newDeps[file];
      }
    } catch (e$) {
      e = e$;
      if (options.watch) {
        console.error('ERROR: ' + e.message);
      } else {
        throw e;
      }
    }
    bundled = CJSEverywhere.bundle(processed, originalEntryPoint, root, options);
    if (options.minify) {
      esmangle = require('esmangle');
      bundled = esmangle.mangle(esmangle.optimize(bundled), { destructive: true });
    }
    cache$2 = escodegen.generate(bundled, {
      comment: !options.minify,
      sourceMap: true,
      sourceMapWithCode: true,
      sourceMapRoot: null != options.sourceMap ? path.relative(path.dirname(options.sourceMap), root) || '.' : void 0,
      format: options.minify ? escodegenCompactFormat : escodegenDefaultFormat
    });
    code = cache$2.code;
    map = cache$2.map;
    if (options.sourceMap) {
      fs.writeFileSync(options.sourceMap, '' + map);
      sourceMappingUrl = options.output ? path.relative(path.dirname(options.output), options.sourceMap) : options.sourceMap;
      code = '' + code + '\n/*\n//@ sourceMappingURL=' + sourceMappingUrl + '\n*/';
    }
    if (options.output) {
      fs.writeFileSync(options.output, code);
    } else {
      process.stdout.write('' + code + '\n');
    }
    return processed;
  };
  startBuild = function () {
    var processed, startWatching, watching;
    if (options.watch) {
      options.cache = {};
      console.error('Building bundle starting at ' + originalEntryPoint);
    }
    processed = build(originalEntryPoint);
    if (options.watch) {
      watching = [];
      return (startWatching = function (processed) {
        return function (accum$) {
          var file;
          for (file in processed) {
            if (!isOwn$(processed, file))
              continue;
            if (!!in$(file, watching))
              continue;
            accum$.push(function (file) {
              watching.push(file);
              return fs.watchFile(file, {
                persistent: true,
                interval: 500
              }, function (curr, prev) {
                if (!curr.ino) {
                  console.error('WARNING: watched file ' + file + ' has disappeared');
                  return;
                }
                console.error('Rebuilding bundle starting at ' + file);
                processed = build(file, processed);
                startWatching(processed);
              });
            }(file));
          }
          return accum$;
        }.call(this, []);
      })(processed);
    }
  };
  if (originalEntryPoint === '-') {
    stdinput = '';
    process.stdin.on('data', function (data) {
      return stdinput += data;
    });
    process.stdin.on('end', function () {
      originalEntryPoint = require('mktemp').createFileSync('temp-XXXXXXXXX.js');
      fs.writeFileSync(originalEntryPoint, stdinput);
      process.on('exit', function () {
        return fs.unlinkSync(originalEntryPoint);
      });
      return startBuild();
    });
    process.stdin.setEncoding('utf8');
    process.stdin.resume();
  } else {
    startBuild();
  }
  function isOwn$(o, p) {
    return {}.hasOwnProperty.call(o, p);
  }
  function in$(member, list) {
    for (var i = 0, length = list.length; i < length; ++i)
      if (i in list && list[i] === member)
        return true;
    return false;
  }
}.call(this);
